#!/usr/bin/env python3
"""
A diagnostic tool for gemini servers.

This program will barrage your server with a series of requests in
an attempt to uncover unexpected behavior. Not all of these checks
adhere strictly to the gemini specification. Some of them are
general best practices, and some trigger undefined behavior. Results
should be taken with a grain of salt and analyzed on their own merit.
"""
import argparse
import contextlib
import datetime
import ipaddress
import socket
import ssl
import sys
import time
import typing
import re

if sys.version_info < (3, 7):
    sys.exit("Fatal Error: script requires Python 3.7+")


__title__ = "Gemini Diagnostics"
__author__ = "Michael Lazar"
__license__ = "MIT"
__copyright__ = "(c) 2020 Michael Lazar"
__version__ = "1.0.0"


socket.setdefaulttimeout(5)


# ANSI color codes
A_BOLD = 1
FG_BLACK = 30
FG_RED = 31
FG_GREEN = 32
FG_YELLOW = 33
FG_BLUE = 34
FG_MAGENTA = 35
FG_CYAN = 36
FG_WHITE = 37


LOG_STYLES = {
    "normal": ["", None],
    "title": ["", A_BOLD],
    "warning": ["  ", FG_YELLOW],
    "info": ["  ", FG_CYAN],
    "success": ["  âœ“ ", FG_GREEN],
    "failure": ["  x ", FG_RED]
}


CHECKS = []


def log(text, style="normal"):
    prefix, color = LOG_STYLES[style]
    if prefix:
        text = prefix + text
    if color and sys.stdout.isatty():
        text = f"\033[{color}m{text}\033[0m"

    print(text)



def log_error(err) -> None:
    text = str(err)
    if isinstance(err, Warning):
        log(text, style="warning")
    else:
        log(text, style="failure")


class GeminiResponse:

    def __init__(self):
        self.header = None
        self.status = None
        self.meta = None
        self.body = None

        # Extra info for 2x success responses
        self.mime = None
        self.params = {}

    def read(self, fp):
        self.header = fp.readline().decode("utf-8")

        log("Response header")
        log(f"{self.header!r}", style="info")

        self.status, *header_rest = self.header.strip().split(maxsplit=1)
        self.meta = header_rest[0] if header_rest else ""

        if not self.meta:
            raise Exception("Status should include a <META> line")

        if self.status.startswith("2"):
            meta_parts = self.meta.split(";")
            self.mime = meta_parts[0].strip()
            for part in meta_parts[1:]:
                name, value = part.strip().split("=", maxsplit=1)
                self.params[name.lower()] = value

        charset = self.params.get("charset", "utf-8")
        self.body = fp.read().decode(charset)


class CheckRegistry(type):

    def __new__(cls, name, bases, namespace):
        cls = type.__new__(cls, name, bases, namespace)
        if name != 'BaseCheck':
            CHECKS.append(cls)
        return cls


class BaseCheck(metaclass=CheckRegistry):

    def __init__(self, args):
        self.args = args
        self.success = False

    def run(self):
        log(f"[{self.__class__.__name__}] {self.__doc__}", style="title")
        try:
            self.check()
        except Exception as e:
            self.success = False
            log_error(e)
        log("")
        return self.success

    def check(self):
        raise NotImplemented

    @property
    def netloc(self):
        if self.args.port == 1965:
            return self.args.host
        else:
            return f"{self.args.host}:{self.args.port}"

    def resolve_host(self, family):
        host = self.args.host
        port = self.args.port
        type_ = socket.SOCK_STREAM
        proto = socket.IPPROTO_TCP
        addr_info = socket.getaddrinfo(host, port, family, type_, proto)
        if not addr_info:
            raise UserWarning(f"No {family} address found for host")

        # Gemini IPv6
        return addr_info[0][4]

    @contextlib.contextmanager
    def connection(self, context=None):
        """
        Setup an unverified TLS socket connection with the host.
        """
        if context is None:
            context = ssl.SSLContext(ssl.PROTOCOL_TLS)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE

        address = (self.args.host, self.args.port)
        with socket.create_connection(address, timeout=5) as sock:
            with context.wrap_socket(sock, server_hostname=self.args.host) as ssock:
                yield ssock

    def make_request(self, url, context=None):
        log("Request URL")
        log(f"{url!r}", style="info")
        with self.connection(context=context) as sock:
            sock.sendall(url.encode(errors="surrogateescape"))
            fp = sock.makefile("rb")
            response = GeminiResponse()
            response.read(fp)
            return response

    def assert_success(self, status):
        log("Status should return a success code (20 SUCCESS)")
        self.log_test(f"Received status of {status!r}", status == "20")

    def assert_permanent_failure(self, status):
        log("Status should return a failure code (5X PERMANENT FAILURE)")
        self.log_test(f"Received status of {status!r}", status.startswith("5"))

    def assert_proxy_refused(self, status):
        log("Status should return a failure code (53 PROXY REQUEST REFUSED)")
        self.log_test(f"Received status of {status!r}", status == "53")

    def assert_bad_request(self, status):
        log("Status should return a failure code (59 BAD REQUEST)")
        self.log_test(f"Received status of {status!r}", status == "59")

    def log_test(self, text, success):
        self.success = success
        if success:
            log(text, "success")
        else:
            log(text, "failure")



class IPv4Address(BaseCheck):
    """Establish a connection over an IPv4 address"""

    def check(self):
        log(f"Looking up IPv4 address for {self.args.host!r}")
        addr = self.resolve_host(socket.AF_INET)
        log(f"{addr[0]!r}", style="success")

        log(f"Attempting to connect to {addr[0]}:{addr[1]}")
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.connect(addr)
            sock.close()
        log(f"Successfully established connection", style="success")
        self.success = True


class IPv6Address(BaseCheck):
    """Establish a connection over an IPv6 address"""

    def check(self):
        log(f"Looking up IPv6 address for {self.args.host!r}")
        addr = self.resolve_host(socket.AF_INET6)
        if ipaddress.ip_address(addr[0]).ipv4_mapped:
            raise UserWarning("Found IPv4-mapped address, skipping check")
        log(f"{addr[0]!r}", style="success")

        log(f"Attempting to connect to [{addr[0]}]:{addr[1]}")
        with socket.socket(socket.AF_INET6, socket.SOCK_STREAM) as sock:
            sock.connect(addr)
            sock.close()
        log(f"Successfully established connection", style="success")
        self.success = True


class TLSVersion(BaseCheck):
    """Server must negotiate at least TLS v1.2, ideally TLS v1.3"""

    def check(self):
        log(f"Checking client library")
        log(f"{ssl.OPENSSL_VERSION!r}", style="info")

        log("Determining highest supported TLS version")
        with self.connection() as sock:
            version = sock.version()
            if version in ("SSLv2", "SSLv3", "TLSv1", "TLSv1.1"):
                log(f"Negotiated {version}", style="failure")
            elif version == "TLSv1.2":
                log(f"Negotiated {version}", style="warning")
                self.success = True
            else:
                log(f"Negotiated {version}", style="success")
                self.success = True


class TLSClaims(BaseCheck):
    """Certificate claims must be valid"""

    def check(self):
        try:
            import cryptography
            from cryptography.hazmat.backends import default_backend
            from cryptography.x509.oid import NameOID, ExtensionOID
        except ImportError:
            raise UserWarning("cryptography library not installed, skipping check")

        with self.connection() as sock:
            # Python refuses to parse a certificate unless the issuer is validated.
            # Because many gemini servers use self-signed certs, we need to use
            # a third-party library to parse the certs from their binary form.
            der_x509 = sock.getpeercert(binary_form=True)
            cert = default_backend().load_der_x509_certificate(der_x509)
            now = datetime.datetime.utcnow()

            log('Checking "Not Valid Before" timestamp')
            self.log_test(f"{cert.not_valid_before} UTC", cert.not_valid_before <= now)

            log('Checking "Not Valid After" timestamp')
            self.log_test(f"{cert.not_valid_after} UTC", cert.not_valid_after >= now)

            log("Checking subject claim matches server hostname")
            subject = []
            for cn in cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME):
                subject.append(("commonName", cn.value))

            subject_alt_name = []
            try:
                ext = cert.extensions.get_extension_for_oid(
                    ExtensionOID.SUBJECT_ALTERNATIVE_NAME
                )
            except cryptography.x509.ExtensionNotFound:
                pass
            else:
                for dns in ext.value.get_values_for_type(cryptography.x509.DNSName):
                    subject_alt_name.append(("DNS", dns))
                for ip_address in ext.value.get_values_for_type(
                    cryptography.x509.IPAddress
                ):
                    subject_alt_name.append(("IP Address", ip_address))

            cert_dict = {
                "subject": (tuple(subject),),
                "subjectAltName": tuple(subject_alt_name),
            }
            log(f"{cert_dict!r}", style="info")
            ssl.match_hostname(cert_dict, self.args.host)
            log(f"Hostname {self.args.host!r} matches claim", style="success")
            self.success = True


class TLSVerified(BaseCheck):
    """Certificate should be self-signed or have a trusted issuer"""

    def check(self):
        log("Connecting over verified SSL socket")
        context = ssl.create_default_context()
        try:
            with socket.create_connection((self.args.host, self.args.port)) as sock:
                with context.wrap_socket(sock, server_hostname=self.args.host) as ssock:
                    ssock.sendall(f"gemini://{self.netloc}\r\n".encode())
        except Exception as e:
            if getattr(e, "verify_code", None) == 18:
                log("Self-signed TLS certificate detected", style="success")
                self.success = True
            else:
                raise
        else:
            log("CA-signed TLS certificate detected", style="warning")


class TLSCloseNotify(BaseCheck):
    """Server should send a close_notify alert before closing the connection"""

    def check(self):
        log("Checking for close_notify TLS signal")

        context = ssl.SSLContext(ssl.PROTOCOL_TLS)
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE

        close_notify_received = False

        def msg_cb(connection, direction, v, c, m, data):
            if m == ssl._TLSAlertType.CLOSE_NOTIFY and direction == 'read':
                nonlocal close_notify_received
                close_notify_received = True

        context._msg_callback = msg_cb

        url = f"gemini://{self.netloc}/\r\n"
        self.make_request(url, context)

        if close_notify_received:
            log("TLS close_notify signal was received successfully", style="success")
            self.success = True
        else:
            log("TLS close_notify signal was not received", style="failure")


class TLSRequired(BaseCheck):
    """Non-TLS requests should be refused"""

    def check(self):
        log("Sending non-TLS request")
        try:
            with socket.create_connection((self.args.host, self.args.port)) as sock:
                sock.sendall(f"gemini://{self.netloc}\r\n".encode())
                fp = sock.makefile("rb")
                header = fp.readline().decode()
                if header:
                    log(f"Received unexpected response {header!r}", style="failure")
                else:
                    log(f"Connection closed by server", style="success")
                    self.success = True
        except Exception as e:
            # A connection error is a valid response
            log(f"{e!r}", style="success")


class ConcurrentConnections(BaseCheck):
    """Server should support concurrent connections"""

    def check(self):
        url = f"gemini://{self.netloc}/\r\n"

        log(f"Attempting to establish two connections")
        with self.connection() as sock:
            log("Opening socket 1", style="info")
            sock.send(url[0].encode())
            with self.connection() as sock2:
                log("Opening socket 2", style="info")
                sock2.sendall(url.encode())
                log("Closing socket 2", style="info")
            sock.sendall(url[1:].encode())
            log("Closing socket 1", style="info")

        log(f"Concurrent connections supported", style="success")
        self.success = True


class ResponseFormat(BaseCheck):
    """Validate the response header and body for the root URL"""

    def check(self):
        url = f"gemini://{self.netloc}/\r\n"
        response = self.make_request(url)

        self.assert_success(response.status)

        log("There should be a single space between <STATUS> and <META>")
        success = response.header[2] == " " and response.header[3] != " "
        self.log_test(f"{response.header[1:4]!r}", success)

        log('Mime type should be "text/gemini"')
        self.log_test(f"{response.mime!r}", response.mime == "text/gemini")

        log(r'Header should end with "\r\n"')
        self.log_test(f"{response.header[-2:]!r}", response.header.endswith("\r\n"))

        log("Body should be non-empty")
        self.log_test(f"{response.body[:50]!r}", response.body)

        log(r'Body should use consistent line endings')
        lines = {"crlf": [], "lf": [], "other": []}
        for line in response.body.splitlines(True):
            if line.endswith("\r\n"):
                lines["crlf"].append(line)
            elif line.endswith("\n"):
                lines["lf"].append(line)
            elif line:
                lines["other"].append(line)

        if lines["other"]:
            log(f"Invalid line ending: {lines['other'][0]!r}", style="failure")
        elif lines["crlf"] and lines["lf"]:
            log("Mixed line endings detected", style="failure")
            log(f"Line 1: {lines['crlf'][0]!r}")
            log(f"Line 2: {lines['lf'][0]!r}")
        elif lines["crlf"]:
            log(r"All lines end with \r\n", style="success")
        elif lines["lf"]:
            log(r"All lines end with \n", style="success")


class HomepageRedirect(BaseCheck):
    """A URL with no trailing slash should redirect to the canonical resource"""

    def check(self):
        url = f"gemini://{self.netloc}\r\n"
        response = self.make_request(url)

        log("Status should return code 31 (REDIRECT PERMANENT)")
        self.log_test(f"{response.status!r}", response.status == "31")

        log('Meta should redirect to location "gemini://[hostname]/"')
        self.log_test(f"{response.meta!r}", response.meta == f"gemini://{self.netloc}/")

        log(r'Header should end with "\r\n"')
        self.log_test(f"{response.header[-2:]!r}", response.header.endswith("\r\n"))

        log("Body should be empty")
        self.log_test(f"{response.body[:50]!r}", response.body == "")


class PageNotFound(BaseCheck):
    """Request a gemini URL that does not exist"""

    def check(self):
        url = f"gemini://{self.netloc}/09pdsakjo73hjn12id78\r\n"
        response = self.make_request(url)

        log("Status should return code 51 (NOT FOUND)")
        self.log_test(f"{response.status!r}", response.status == "51")

        log('Header should end with "\\r\\n"')
        self.log_test(f"{response.header[-2:]!r}", response.header.endswith("\r\n"))

        log("Body should be empty")
        self.log_test(f"{response.body[:50]!r}", response.body == "")


class RequestMissingCR(BaseCheck):
    """A request without a <CR> should timeout"""

    def check(self):
        url = f"gemini://{self.netloc}/\n"
        try:
            response = self.make_request(url)
        except Exception as e:
            log("No response should be received")
            log(f"{e}", style="success")
            self.success = True
        else:
            log("No response should be received")
            log(f"{response.status!r}", style="failure")


class URLIncludePort(BaseCheck):
    """Send the URL with the port explicitly defined"""

    def check(self):
        url = f"gemini://{self.args.host}:{self.args.port}/\r\n"
        response = self.make_request(url)
        self.assert_success(response.status)


class URLSchemeMissing(BaseCheck):
    """A URL without a scheme should be inferred as gemini"""

    def check(self):
        url = f"//{self.netloc}/\r\n"
        response = self.make_request(url)
        self.assert_success(response.status)


class URLByIPAddress(BaseCheck):
    """Send the URL using the IPv4 address"""

    def check(self):
        addr = self.resolve_host(socket.AF_INET)
        url = f"gemini://{addr[0]}:{addr[1]}/\r\n"
        response = self.make_request(url)

        log("Verify that the status matches your desired behavior")
        log(f"{response.status!r}", style="success")
        self.success = True


class URLInvalidUTF8Byte(BaseCheck):
    """Send a URL containing a non-UTF8 byte sequence"""

    def check(self):
        non_utf8_character = "\udcdc"  # Surrogate-escaped byte sequence
        url = f"gemini://{self.netloc}/{non_utf8_character}\r\n"

        try:
            response = self.make_request(url)
        except Exception:
            response = None

        log("Connection should either drop, or return 59 (BAD REQUEST)")
        if response is None:
            log("Connection closed without response", style="success")
        else:
            self.log_test(f"{response.status!r}", response.status == "59")


class URLMaxSize(BaseCheck):
    """Send a 1024 byte URL, the maximum allowed size"""

    def check(self):
        # Per the spec, the <CR><LF> are not included in the total size
        base_url = f"gemini://{self.netloc}/"
        buffer = "0" * (1024 - len(base_url.encode("utf-8")))
        url = base_url + buffer + "\r\n"

        response = self.make_request(url)
        log("Status should return code 51 (NOT FOUND)")
        self.log_test(f"{response.status!r}", response.status == "51")


class URLAboveMaxSize(BaseCheck):
    """Send a 1025 byte URL, above the maximum allowed size"""

    def check(self):
        # Per the spec, the <CR><LF> are not included in the total size
        base_url = f"gemini://{self.netloc}/"
        buffer = "0" * (1025 - len(base_url.encode("utf-8")))
        url = base_url + buffer + "\r\n"

        try:
            response = self.make_request(url)
        except Exception:
            response = None

        log("Connection should either drop, or return 59 (BAD REQUEST)")
        if response is None:
            log("Connection closed without response", style="success")
        else:
            self.log_test(f"{response.status!r}", response.status == "59")


class URLWrongPort(BaseCheck):
    """A URL with an incorrect port number should be rejected"""

    def check(self):
        url = f"gemini://{self.args.host}:443/\r\n"
        response = self.make_request(url)
        self.assert_proxy_refused(response.status)


class URLWrongHost(BaseCheck):
    """A URL with a foreign hostname should be rejected"""

    def check(self):
        url = f"gemini://wikipedia.org/\r\n"
        response = self.make_request(url)
        self.assert_proxy_refused(response.status)


class URLSchemeHTTP(BaseCheck):
    """Send a URL with an HTTP scheme"""

    def check(self):
        url = f"http://{self.netloc}/\r\n"
        response = self.make_request(url)
        self.assert_proxy_refused(response.status)


class URLSchemeHTTPS(BaseCheck):
    """Send a URL with an HTTPS scheme"""

    def check(self):
        url = f"https://{self.netloc}/\r\n"
        response = self.make_request(url)
        self.assert_proxy_refused(response.status)


class URLSchemeGopher(BaseCheck):
    """Send a URL with a Gopher scheme"""

    def check(self):
        url = f"gopher://{self.netloc}/\r\n"
        response = self.make_request(url)
        self.assert_proxy_refused(response.status)


class URLEmpty(BaseCheck):
    """Empty URLs should not be accepted by the server"""

    def check(self):
        url = f"\r\n"
        response = self.make_request(url)
        self.assert_bad_request(response.status)


class URLRelative(BaseCheck):
    """Relative URLs should not be accepted by the server"""

    def check(self):
        url = f"/\r\n"
        response = self.make_request(url)
        self.assert_bad_request(response.status)


class URLInvalid(BaseCheck):
    """Random text should not be accepted by the server"""

    def check(self):
        url = f"Hello Gemini!\r\n"
        response = self.make_request(url)
        self.assert_bad_request(response.status)


class URLDotEscape(BaseCheck):
    """A URL should not be able to escape the root using dot notation"""

    def check(self):
        url = f"gemini://{self.netloc}/../../\r\n"
        response = self.make_request(url)
        self.assert_permanent_failure(response.status)


# noinspection PyTypeChecker
# fmt: off
parser = argparse.ArgumentParser(
    usage="%(prog)s [host] [port] [--help]",
    description=__doc__,
    formatter_class=argparse.RawDescriptionHelpFormatter,
)
parser.add_argument(
    "host",
    nargs="?",
    default="localhost",
    help="server hostname (default: localhost)"
)
parser.add_argument(
    "port",
    nargs="?",
    type=int,
    default=1965,
    help="server port (default: 1965)",
)
parser.add_argument(
    "-V", "--version",
    action="version",
    version="gemini-diagnostics " + __version__
)
parser.add_argument(
    "--checks",
    help="comma separated list of checks to apply"
)
parser.add_argument(
    "--show-checks",
    action="store_true",
    help="display the complete list of checks and exit",
)
parser.add_argument(
    "--export-checks-as-html",
    action="store_true",
    help=argparse.SUPPRESS,
)
parser.add_argument(
    "--delay",
    type=float,
    default=1,
    help="seconds to sleep between checks (default: 1)",
)
# fmt: on


def run():
    args = parser.parse_args()

    if args.export_checks_as_html:
        # Hidden option, used to generate the text for the README page.
        print("<dl>")
        for check in CHECKS:
            print(f"<dt>[{check.__name__}]</dt>")
            print(f"<dd>{check.__doc__}.</dd>")
            print("")
        print("</dl>")
        return

    if args.show_checks:
        for check in CHECKS:
            log(f"[{check.__name__}]", style="title")
            log(f"{check.__doc__}\n")
        return

    if args.checks:
        check_names = {cls.__name__: cls for cls in CHECKS}
        check_list = []
        for name in args.checks.split(","):
            name = name.strip()
            if name not in check_names:
                raise ValueError(f"unknown check {name!r}")
            check_list.append(check_names[name])
    else:
        check_list = CHECKS

    log(f"Running server diagnostics check against {args.host}:{args.port}")
    log("...\n")
    all_pass = True
    for check in check_list:
        time.sleep(args.delay)
        all_pass = check(args).run() and all_pass
    log("Done!")
    return 0 if all_pass else 1


if __name__ == "__main__":
    sys.exit(run())
